(numericals.common:compiler-in-package numericals.common:*compiler-package*)

(define-polymorphic-function la:qr (array-like &key q r) :overwrite t
  :documentation "Calculate the QR decomposition of ARRAY-LIKE.")

(defun out-shape-compatible-for-qr-p (a q r)
  (declare (type simple-array a q r)
           (optimize speed))
  (and (equal (narray-dimensions a) (narray-dimensions r))
       (let ((rank (nu:array-rank a)))
         (and (= rank (nu:array-rank q))
              (if (< rank 2)
                  nil
                  (and (loop :for d1 :of-type (integer 0 #.array-dimension-limit)
                               :in (narray-dimensions a)
                             :for d2 :of-type (integer 0 #.array-dimension-limit)
                               :in (narray-dimensions q)
                             :repeat (- rank 2)
                             :always (= d1 d2))
                       (= (array-dimension a (- rank 2))
                          (array-dimension q (- rank 2)))
                       (= (array-dimension q (- rank 1))
                          (array-dimension q (- rank 2)))))))))

(defpolymorph la:qr ((a (simple-array <type>))
                     &key ((q (simple-array <type>)))
                     ((r (simple-array <type>))))
    (values (simple-array <type>) (simple-array <type>))
  (policy-cond:with-expectations (= 0 safety)
      ((assertion (out-shape-compatible-for-qr-p a q r)
                  ()
                  "Incompatible shapes of Q ~A and R ~A~%to compute QR decomposition of array of shape ~A"
                  (narray-dimensions q) (narray-dimensions r) (narray-dimensions a)))
    (let* ((c-size (c-size <type>))
           (a-layout (eigen-array-layout a))
           (q-layout (eigen-array-layout q))
           (r-layout (eigen-array-layout r))
           (rank   (nu:array-rank a))
           (m (nu:array-dimension a (- rank 2)))
           (n (nu:array-dimension a (- rank 1)))
           (c-name (c-name <type> 'la:qr)))
      (flet ((qr (a-size a-ptr a-dims q-ptr q-dims r-ptr r-dims)
               (declare (ignore a-size a-dims q-dims r-dims))
               (inline-or-funcall c-name m n
                                  a-ptr a-layout
                                  q-ptr q-layout
                                  r-ptr r-layout)))
        (with-simple-array-broadcast (qr 2 2 2) (a c-size) (q c-size) (r c-size)))
      (values q r))))

(defun out-shape-for-q (a)
  (declare (type simple-array a)
           (optimize speed))
  (let ((rank (nu:array-rank a)))
    (if (< rank 2)
        (error "QR decomposition requires array of rank at least 2")
        (nconc (subseq (narray-dimensions a) 0 (- rank 2))
               (list (array-dimension a (- rank 2))
                     (array-dimension a (- rank 2)))))))

(defun out-shape-for-r (a)
  (declare (type simple-array a)
           (optimize speed))
  (array-dimensions a))

(defpolymorph (la:qr :inline t) ((a (simple-array <type>))
                                 &key ((q null)) ((r null)))
    (or number (simple-array <type>))
  (declare (ignore q r))
  (pflet ((q (nu:empty (out-shape-for-q a) :type <type>))
          (r (nu:empty (out-shape-for-r a) :type <type>)))
    (declare (type (simple-array <type>) q r))
    (la:qr a :q q :r r)))

(defpolymorph (la:qr :inline t) ((a list) &key ((q null)) ((r null)))
    simple-array
  (declare (ignore q r))
  (la:qr (nu:asarray a :type nu:*default-float-format*)))

(defpolymorph (la:qr :inline t) ((a list)
                                 &key ((q (simple-array <type>)))
                                 ((r (simple-array <type>))))
    (simple-array <type>)
  (la:qr (nu:asarray a :type <type>) :q q :r r))
