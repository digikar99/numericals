(numericals.common:compiler-in-package numericals.common:*compiler-package*)

(5am:in-suite nu::array)

(define-polymorphic-function nu:two-arg-matmul (a b &key out) :overwrite t)

(defun out-shape-compatible-for-matmul-p (a b out)
  (declare (type simple-array a b out)
           (optimize speed))
  (let ((rank (nu:array-rank a)))
    (and (= rank (nu:array-rank b) (nu:array-rank out))
         (if (< rank 2)
             nil
             (and (loop :for d1 :of-type (integer 0 #.array-dimension-limit)
                          :in (narray-dimensions a)
                        :for d2 :of-type (integer 0 #.array-dimension-limit)
                          :in (narray-dimensions b)
                        :for d3 :of-type (integer 0 #.array-dimension-limit)
                          :in (narray-dimensions out)
                        :repeat (- rank 2)
                        :always (= d1 d2 d3))
                  (= (array-dimension a (- rank 2))
                     (array-dimension out (- rank 2)))
                  (= (array-dimension b (- rank 1))
                     (array-dimension out (- rank 1))))))))

(defpolymorph nu:two-arg-matmul ((a (simple-array <type>))
                                 (b (simple-array <type>))
                                 &key ((out (simple-array <type>))))
    (simple-array <type>)
  (policy-cond:with-expectations (= 0 safety)
      ((assertion (out-shape-compatible-for-matmul-p a b out)
                  ()
                  "Arrays of shape ~A and ~A cannot be~%multiplied to produce an array of shape ~A."
                  (narray-dimensions a) (narray-dimensions b) (narray-dimensions out)))
    (let ((c-size (c-size <type>))
          (c-name (c-name <type> 'nu:matmul))
          (a-layout (ecase (array-layout a)
                      (:row-major 82)
                      (:column-major 67)))
          (b-layout (ecase (array-layout b)
                      (:row-major 82)
                      (:column-major 67)))
          (o-layout (ecase (array-layout out)
                      (:row-major 82)
                      (:column-major 67))))
      (flet ((matmul (a-size a-ptr a-dims b-ptr b-dims o-ptr o-dims)
               (declare (ignore a-size o-dims))
               (let ((m (first a-dims))
                     (n (second a-dims))
                     (k (second b-dims)))
                 (inline-or-funcall c-name m n k
                                    a-ptr a-layout
                                    b-ptr b-layout
                                    o-ptr o-layout))))
        (with-simple-array-broadcast (matmul 2 2 2)
          (a c-size) (b c-size) (out c-size)))
      out)))

(defun out-shape-for-matmul (a b)
  (declare (type simple-array a b)
           (optimize speed))
  (let ((rank (nu:array-rank a)))
    (assert (= rank (nu:array-rank b)))
    (if (< rank 2)
        (error "Matmul requires arrays of at least rank 2")
        (nconc (if (loop :for d1 :of-type (integer 0 #.array-dimension-limit)
                           :in (narray-dimensions a)
                         :for d2 :of-type (integer 0 #.array-dimension-limit)
                           :in (narray-dimensions b)
                         :repeat (- rank 2)
                         :always (= d1 d2))
                   (subseq (array-dimensions a) 0 (- rank 2))
                   (error "Incompatible dimensions for matmul"))
               (list (array-dimension a (- rank 2))
                     (array-dimension b (- rank 1)))))))

(defpolymorph (nu:two-arg-matmul :inline t :suboptimal-note runtime-array-allocation)

    ((a (simple-array <type>))
     (b (simple-array <type>))
     &key ((out null)))
    (simple-array <type>)

  (declare (ignore out))
  (pflet ((out (nu:empty (out-shape-for-matmul a b) :type <type>)))
    (declare (type (simple-array <type>) out))
    (nu:two-arg-matmul a b :out out)
    out))

(defpolymorph (nu:two-arg-matmul :inline t
                                 :more-optimal-type-list
                                 ((simple-array <type>)
                                  (simple-array <type>)
                                  &key (:out (simple-array <type>))))
    (a b &key ((out null)))
    simple-array
  (declare (ignore out))
  (nu:two-arg-matmul (nu:asarray a :type nu:*default-float-format*)
                     (nu:asarray b :type nu:*default-float-format*)))

(defpolymorph (nu:two-arg-matmul :inline t
                                 :more-optimal-type-list
                                 ((simple-array <type>)
                                  (simple-array <type>)
                                  &key (:out (simple-array <type>))))
    (a b &key ((out (simple-array <type>))))
    simple-array
  (let ((type (array-element-type out)))
    (nu:two-arg-matmul (nu:asarray a :type type)
                       (nu:asarray b :type type)
                       :out out)))

(5am:def-test nu:two-arg-matmul ()
  (let ((cl-array-p (string= "NUMERICALS" (package-name (find-package :nu)))))
    (loop :for nu:*array-element-type* :in '(single-float double-float)
          :do (loop :for nu:*array-layout* :in (if cl-array-p
                                                   '(:row-major)
                                                   '(:row-major :column-major))
                    :do
                       (5am:is (nu:array= (nu:asarray '((2)))
                                          (nu:two-arg-matmul (nu:asarray '((1)))
                                                             (nu:asarray '((2)))
                                                             :out (nu:zeros 1 1))))
                       (5am:is (nu:array= (nu:asarray '((8)))
                                          (nu:two-arg-matmul (nu:asarray '((1 2)))
                                                             (nu:asarray '((2) (3)))
                                                             :out (nu:zeros 1 1))))
                       (5am:is (nu:array= (nu:asarray '((2 4)
                                                        (3 6)))
                                          (nu:two-arg-matmul (nu:asarray '((2) (3)))
                                                             (nu:asarray '((1 2)))
                                                             :out (nu:zeros 2 2))))
                       (5am:is (nu:array= (nu:asarray '((2 4)
                                                        (3 6)
                                                        (1 2)))
                                          (nu:two-arg-matmul (nu:asarray '((2) (3) (1)))
                                                             (nu:asarray '((1 2)))
                                                             :out (nu:zeros 3 2))))
                       (5am:is (nu:array= (nu:asarray '((2 4)
                                                        (3 6)
                                                        (1 2)))
                                          (nu:two-arg-matmul (nu:asarray '((2) (3) (1)))
                                                             (nu:asarray '((1 2))))))
                       (5am:is (nu:array= (nu:asarray '((-3 0) (-5 2)))
                                          (nu:two-arg-matmul (nu:asarray '((1 2) (3 4)))
                                                             (nu:asarray '((1 2) (-2 -1))))))
                       (5am:signals error (nu:two-arg-matmul (nu:asarray '((2) (3) (1)))
                                                             (nu:asarray '((1 2 3)))
                                                             :out (nu:zeros 3 2))))
              ;; Mixed layout
              (unless cl-array-p
                (5am:is (nu:array= (nu:asarray '((-3 0) (-5 2)) :layout :row-major)
                                   (nu:two-arg-matmul (nu:asarray '((1 2) (3 4))
                                                                  :layout :row-major)
                                                      (nu:asarray '((1 2) (-2 -1))
                                                                  :layout :column-major))))
                (5am:is (nu:array= (nu:asarray '((-3 0) (-5 2)) :layout :column-major)
                                   (nu:two-arg-matmul (nu:asarray '((1 2) (3 4)) :layout :column-major)
                                                      (nu:asarray '((1 2) (-2 -1)) :layout :row-major))))
                (5am:is (nu:array= (nu:asarray '((-3 0) (-5 2)) :layout :column-major)
                                   (nu:two-arg-matmul (nu:asarray '((1 2) (3 4)) :layout :column-major)
                                                      (nu:asarray '((1 2) (-2 -1)) :layout :row-major)
                                                      :out (nu:zeros 2 2 :layout :row-major))))))))

(define-polymorphic-function nu:matmul (matrix &rest matrices))

(define-condition matmul-runtime-allocation (runtime-array-allocation)
  ()
  (:report (lambda (c s)
             (declare (ignore c))
             (format s "n-ary MATMUL cannot avoid runtime array allocation. Use the binary/ternary TWO-ARG-MATMUL instead and supply and the OUT argument for it."))))

(defpolymorph (nu:matmul :suboptimal-note runtime-array-allocation)
    ((m1 (simple-array <type>)) (m2 (simple-array <type>)))
    (simple-array <type>)
  (nu:two-arg-matmul m1 m2))

(defpolymorph (nu:matmul :suboptimal-note runtime-array-allocation)
    ((m1 (simple-array <type>))
     (m2 (simple-array <type>))
     &rest matrices)
    (simple-array <type> 2)
  (loop :with out := (nu:two-arg-matmul m1 m2)
        :for m :in matrices
        :do (setq out (nu:two-arg-matmul out m))
        :finally (return out)))

(defpolymorph (nu:matmul :suboptimal-note runtime-array-allocation)
    (m1 m2 &rest matrices)
    simple-array
  (loop :with out := (nu:two-arg-matmul m1 m2)
        :for m :in matrices
        :do (setq out (nu:two-arg-matmul out m))
        :finally (return out)))
