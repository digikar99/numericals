<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="None" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>(dense-)numericals</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Numerical Computing in Common Lisp";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/lisp.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="." class="icon icon-home"> (dense-)numericals
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="intro/">Introduction</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="install/">Installation</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="current-state/">Current State</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="api/">API Reference</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href=".">(dense-)numericals</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>Numerical Computing in Common Lisp</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="numerical-computing-in-common-lisp">Numerical Computing in Common Lisp</h1>
<blockquote>
<p>Currently, <code>numericals</code> and <code>dense-numericals</code> provides fast arithmetic, comparison, logical, transcendental, and float-rounding operations. While it is possible to use linear algebra routines by <a href="#interfacing-with-magicl">interfacing with magicl</a>, unless there is sufficient interest, given (i) the limited developer time (ii) the lack of fast basic mathematic libraries in Common Lisp*, <code>numericals</code> and <code>dense-numericals</code> does not aim to provide fast linear algebra operations at the moment. Improving the interface would be at a higher priority.</p>
<p>*There are a fair number of maintained and unmaintained numerical/scientific computing libraries providing (incomplete) linear algebra routines in Common Lisp - <a href="https://github.com/quil-lang/magicl">magicl</a>, <a href="https://gsll.common-lisp.dev/">gsll</a>, <a href="https://github.com/blindglobe/lisp-matrix">lisp-matrix</a> <a href="https://github.com/Lisp-Stat/numerical-utilities">lisp-stat/numerical-utilities</a> (see <a href="https://github.com/CodyReichert/awesome-cl#numerical-and-scientific">awesome-cl</a>) - yet none has bothered (or needed?) SIMD based fast basic mathematical operations. This library therefore does not wish to focus on linear algebra before getting the fast basic mathematical operations get suitably polished.</p>
</blockquote>
<h2 id="getting-started">Getting started</h2>
<p>Click one of the below links depending on your (i) proficiency in programming (ii) proficiency in Common Lisp (iii) the task at hand.</p>
<ul>
<li>I want to get things done reasonably fast. I don't care about maximizing runtime performance so long as it isn't abysmal.</li>
<li>I want to operate on CLHS provided arrays. They are good enough for me. I don't care about your "new fancy XYZ arrays".</li>
<li>
<p>I'm curious about these new fancy arrays. I myself have a fair share of problems with CLHS provided arrays, and certainly wish they could be better.</p>
</li>
<li>
<p>I want to extract the maximum juice out of my machine. I know why I need it. I care about every last bit of performance.</p>
</li>
<li>I'm happy with CLHS provided arrays, OR I wish we had a better alternative to CLHS arrays.</li>
<li>I'm a reasonably proficient lisper and have a basic idea about maximizing performance, OR I'm new to lisp, but I have a basic idea about maximizing performance, OR I'm new to lisp, and this will be amongst my first times learning to optimize performance.</li>
</ul>
<h2 id="design-decisions">Design Decisions</h2>
<ul>
<li>Why not GSL? GSL uses its own vector and matrix wrappers, and while one can certainly make CFFI use them, it doesn't seem like a good way. Using BLAS and LAPACK looks better.</li>
</ul>
<h2 id="getting-started_1">Getting started</h2>
<p>If you are happy with Common Lisp arrays, you can <code>(ql:quickload "numericals")</code>. Otherwise if you think arrays could look nicer, and think numpy's way of doing things are sensible*, then you can <code>(ql:quickload "dense-numericals")</code>.</p>
<pre><code class="language-lisp">(uiop:define-package :numericals-demo
  ;; (:mix :numericals :cl))
  (:mix :dense-numericals :dense-arrays-plus-lite :cl))
</code></pre>
<h3 id="an-introduction-to-dense-arrays">An introduction to dense-arrays</h3>
<p>The arrays that <code>dense-numericals</code> works on are provided by <a href="https://github.com/digikar99/dense-arrays/">dense-arrays</a>. At its simplest, these are wrappers around <code>cl:vector</code> and enable numpy-like* copy-free slicing aka copy-free selection of array elements / axes. </p>
<pre><code class="language-lisp">CL-USER&gt; (setq cl:*print-length* 10)
CL-USER&gt; (let ((a (cl:make-array '(1000 1000))))
           (select:select a t 0)) ; select the 0th element of every row
#(0 0 0 0 0 0 0 0 0 0 ...)
CL-USER&gt; (let ((a (dense-arrays:make-array '(1000 1000))))
           (dense-arrays:aref a nil 0)) ; select the 0th element of every row
#&lt;STANDARD-DENSE-ARRAY NIL 1000 T
  0
  0
  0
  0
  0
  0
  0
  0
  0
  0
  ...
 {10511DAA23}&gt;
CL-USER&gt; (let ((a (cl:make-array '(1000 1000))))
           (time (loop for i below 1000 do (select:select a t i))))
Evaluation took:
  0.159 seconds of real time
  0.159541 seconds of total run time (0.159541 user, 0.000000 system)
  100.63% CPU
  352,387,000 processor cycles
  10,863,248 bytes consed

NIL
CL-USER&gt; (let ((a (dense-arrays:make-array '(1000 1000))))
           (time (loop for i below 1000 do (dense-arrays:aref a nil i))))
Evaluation took:
  0.000 seconds of real time
  0.000910 seconds of total run time (0.000878 user, 0.000032 system)
  100.00% CPU
  2,001,298 processor cycles
  261,904 bytes consed

NIL
</code></pre>
<p>Here, the <a href="https://lisp-stat.github.io/select/#index-Generic-Function_002c-select">select:select</a> operation copies over the elements of the array into the new array. While the <code>dense-arrays:aref</code> merely returns another wrapper over a certain section of the array. Note that it is not that <code>select:select</code> purposefully copies over the elements; the case is that given the way Common Lisp arrays are, it actually is not possible to implement the functionality of <code>select:select</code> efficiently. For instance, <a href="https://numcl.github.io/numcl/#src/2aref.lisp">numcl:aref</a> provides a similar functionality as <code>select:select</code>, however it too is slow in the general case:</p>
<pre><code class="language-lisp">CL-USER&gt; (let ((a (numcl:zeros '(1000 1000) :type t)))
           ;; select the ith element of all the rows, aka select the ith column
           (time (loop for i below 1000 do (numcl:aref a t i))))
Evaluation took:
  7.287 seconds of real time
  7.290938 seconds of total run time (7.290938 user, 0.000000 system)
  [ Run times consist of 0.051 seconds GC time, and 7.240 seconds non-GC time. ]
  100.05% CPU
  16,097,057,600 processor cycles
  1,752,658,096 bytes consed

NIL
CL-USER&gt; (let ((a (numcl:zeros '(1000 1000) :type t)))
           ;; select the ith element of all the columns, aka select the ith row
           (time (loop for i below 1000 do (numcl:aref a i t))))
Evaluation took:
  0.000 seconds of real time
  0.001688 seconds of total run time (0.001618 user, 0.000070 system)
  100.00% CPU
  3,718,742 processor cycles
  457,408 bytes consed

NIL
</code></pre>
<p>The second case is faster here, because <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_mk_ar.htm">cl:make-array</a> does provide <code>displaced-to</code> and <code>displaced-index-offset</code> which enable the creation of "wrapper" non-simple arrays if the elements are contiguous. This works only for the rightmost dimension, which is why in <code>(numcl:aref a i t)</code> with <code>t</code> being the rightmost index indicating "select all the elements along this axis", there is a way to avoid copying the array elements, but <code>(numcl:aref a t i)</code> necessitates copying.</p>
<p>By contrast, <code>dense-arrays::dense-array</code> provide for multidimensional strides and offsets, enabling copy free slicing for arbitrary axes. This enables the interpretation of the same <code>cl:vector</code> (the <code>storage</code> slot below) in multiple ways:</p>
<pre><code class="language-lisp">DENSE-ARRAYS&gt; (make-array '(2 3) :constructor #'+)
#&lt;STANDARD-DENSE-ARRAY 2x3 :ROW-MAJOR T
   (0 1 2)
   (1 2 3)
 {100330F653}&gt;
DENSE-ARRAYS&gt; (describe *)
#&lt;STANDARD-DENSE-ARRAY 2x3 :ROW-MAJOR T {100330F653}&gt;
  [standard-object]

Slots with :INSTANCE allocation:
  STORAGE                        = #(0 1 2 1 2 3)
  DIMENSIONS                     = (2 3)
  ELEMENT-TYPE                   = T
  RANK                           = 2
  TOTAL-SIZE                     = 6
  STRIDES                        = (3 1)
  OFFSETS                        = (0 0)
  LAYOUT                         = :ROW-MAJOR
  ROOT-ARRAY                     = NIL
; No value
DENSE-ARRAYS&gt; (aref (make-array '(2 3) :constructor #'+) 1)
#&lt;STANDARD-DENSE-ARRAY NIL 3 T
   1
   2
   3
 {10033B1543}&gt;
DENSE-ARRAYS&gt; (aref (make-array '(2 3) :constructor #'+) nil 1)
#&lt;STANDARD-DENSE-ARRAY NIL 2 T
   1
   2
 {10033B23E3}&gt;
DENSE-ARRAYS&gt; (describe *)
#&lt;STANDARD-DENSE-ARRAY NIL 2 T  {10033B23E3}&gt;
  [standard-object]

Slots with :INSTANCE allocation:
  STORAGE                        = #(0 1 2 1 2 3)
  DIMENSIONS                     = (2)
  ELEMENT-TYPE                   = T
  RANK                           = 1
  TOTAL-SIZE                     = 2
  STRIDES                        = (3)
  OFFSETS                        = (1)
  CONTIGUOUS-P                   = NIL
  ROOT-ARRAY                     = #&lt;STANDARD-DENSE-ARRAY 2x3 T  {10033B2183}&gt;
; No value
</code></pre>
<p>Indeed this also means that the arrays might not be contiguous. Contiguous dense arrays are of type <code>dense-arrays:simple-array</code>; for such arrays, <code>(array-layout dense-array)</code> returns either <code>:row-major</code> or <code>:column-major</code> which is also seen in the printed representations above. Otherwise if <code>(array-layout dense-array)</code> returns <code>nil</code>, then there is no guarantee that the array is a contiguous array, and one can use <code>dense-arrays:make-array</code> or <code>dense-arrays:copy-array</code> to obtain a <code>dense-arrays:simple-array</code> aka contiguous array.</p>
<p>Dense arrays provides two major types <code>(dense-arrays:array &amp;optional element-type rank/dimensions)</code> and <code>(dense-arrays:simple-array &amp;optional element-type rank/dimensions)</code> analogous to their CL counterparts. These should work with <code>typep</code> and <code>subtypep</code>, a caveat being that without the use of <a href="https://github.com/digikar99/extensible-compound-types">extensible-compound-types</a>, the dimensions are reduced to ranks. Thus, </p>
<pre><code class="language-lisp">CL-USER&gt; (alexandria:type= '(dense-arrays:array * (2 3 4)) ; based on CL:TYPEP
                           '(dense-arrays:array * 3))
T
T
CL-USER&gt; (extensible-compound-types:type= '(dense-arrays:array * (2 3 4))
                                          '(dense-arrays:array * 3))
NIL
T
</code></pre>
<p>For advanced usage relating to customizing the behavior of dense-arrays, see <a href="https://github.com/digikar99/dense-arrays/blob/main/DOC.org">here</a>. For a demonstration on optimizing dense-arrays, see <a href="https://github.com/digikar99/dense-arrays/blob/main/perf.org">here</a> (you just need to use <code>dense-arrays:do-arrays</code> and declare the types!).</p>
<p>*Numpy arrays with their multidimensional strides and offsets might not be the best way to do things either. See <a href="https://www.reddit.com/r/lisp/comments/wei81o/comment/iitttgb/?utm_source=share&amp;utm_medium=web2x&amp;context=3">here</a> for a discussion.</p>
<h3 id="using-numericals-to-extend-numericals-implementing-mean">Using numericals to extend numericals: implementing <code>mean</code></h3>
<p>As I write this, numericals already has the following operators: <code>sum divide expt multiply</code> operation.</p>
<p>In this section, we implement the <code>mean</code> operator as a simple wrapper around the existing operators. We start with a basic runtime correct function, but also go into compile time notes and optimizations.</p>
<h4 id="getting-the-correct-answer-at-runtime">Getting the correct answer at runtime</h4>
<p>We start with <code>mean</code>, and take an inspiration from <a href="https://numpy.org/doc/stable/reference/generated/numpy.mean.html">numpy</a> to formulate the function's parameter list:</p>
<pre><code class="language-lisp">(numericals.common:compiler-in-package numericals.common:*compiler-package*)

(define-polymorphic-function nu:mean (array-like &amp;key out axes keep-dims) :overwrite t)
</code></pre>
<p>We use <code>array-like</code> here, since from the user's perspective it will be convenient to avoid having to explicitly cast it into an array. Thus, immediately at the outset, we have two cases:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like list) &amp;key out axes keep-dims) t
  ...)
(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  ...)
</code></pre>
<p>The subtype polymorphism provided by polymorphic-functions should help with the optimization: we should only be required to define a few cases for the <code>nu:array</code>, without bothering about each array-element-type. For the <code>list</code> case, the simplest definition would be:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like list) &amp;key out axes keep-dims) t
  (nu:mean (nu:asarray array-like) :out out :axes axes :keep-dims keep-dims))
</code></pre>
<p>Since a runtime array allocation is involved, we include a <code>suboptimal-note</code> in our definition, so that the user can be helped later. In addition, we also know that inlining this function won't cost much in terms of code bloat and there is a guarantee of non-recursion, thus we also provide an <code>:inline t</code> option to override polymorphic function's note about not inlining it.</p>
<pre><code class="language-lisp">(defpolymorph (nu:mean :inline t :suboptimal-note runtime-array-allocation)
    ((array-like list) &amp;key out axes) t
  (nu:mean (nu:asarray array-like) :out out :axes axes))
</code></pre>
<p>We will return to this case later. But now, let's start with the polymorph for <code>nu:array</code>. The plan is to calculate the <code>sum</code> and then divide by the <code>number-of-elements</code>:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (let* ((sum (nu:sum array :out out :axes axes :keep-dims keep-dims))
         (number-of-elements ...))
    (nu:divide sum number-of-elements :out out)))
</code></pre>
<p>Wherever possible, we supply the <code>out</code> argument. <code>sum</code> could either be an array, or it could be a real. To calculate the <code>number-of-elements</code>, we consider three cases: <code>axes</code> is NIL, or an integer, or a list of integers.</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
         (number-of-elements
           (etypecase axes
             (null (array-total-size array-like))
             (integer (nu:shape array-like axes))
             (list (loop :for d :in (narray-dimensions array-like)
                         :for i :from 0
                         :with number-of-elements := 1
                         :if (member i axes)
                           :do (setf number-of-elements (* number-of-elements d))
                         :finally (return number-of-elements))))))
    (declare (type real number-of-elements))
    (nu:divide sum number-of-elements :out out)))
</code></pre>
<p>These two polymorphs seem enough to get us the required functionality at runtime. We can check out a few cases to see if the function is working correctly. Ideally, writing a test case would be recommendable.</p>
<pre><code class="language-lisp">IMPL&gt; (numericals.common:compiler-in-package numericals.common:*compiler-package*)
#&lt;PACKAGE &quot;DENSE-NUMERICALS.IMPL&quot;&gt;
IMPL&gt; (setq nu:*array-element-type* 'single-float)
SINGLE-FLOAT
IMPL&gt; (nu:mean '(1 2 3))
2.0
IMPL&gt; (nu:mean '(1 2 3.5))
2.1666667
IMPL&gt; (nu:mean '((1 2 3) (4 5 6)))
3.5
IMPL&gt; (nu:mean '((1 2 3) (4 5 6)) :axes 0)
#&lt;STANDARD-DENSE-ARRAY :ROW-MAJOR 3 SINGLE-FLOAT
    2.500
    3.500
    4.500
 {10596A0B33}&gt;
IMPL&gt; (nu:mean '((1 2 3) (4 5 6)) :axes 1)
#&lt;STANDARD-DENSE-ARRAY :ROW-MAJOR 2 SINGLE-FLOAT
    2.000
    5.000
 {10596A47C3}&gt;
IMPL&gt; (nu:mean '((1 2 3) (4 5 6)) :axes 1 :keep-dims t)
#&lt;STANDARD-DENSE-ARRAY :ROW-MAJOR 2x1 SINGLE-FLOAT
  (  2.000    )
  (  5.000    )
 {102447F653}&gt;
IMPL&gt; (nu:mean '((1 2 3) (4 5 6)) :keep-dims t)
#&lt;STANDARD-DENSE-ARRAY :ROW-MAJOR 1x1 SINGLE-FLOAT
  (  3.500    )
 {102448B023}&gt;
</code></pre>
<p>Indeed, these seem good enough. Now let's turn to optimization and compiler notes!</p>
<h4 id="optimizing-a-specific-case-of-numean">Optimizing a specific case of nu:mean</h4>
<p>For this part, it is helpful to use ALIVE or SLIME or equivalent, so that you can <em>compile</em> one form at a time and see the notes and warnings corresponding to it. We will be trying to optimize a simpler single-float-mean function that calculates the overall mean of single float arrays.</p>
<p>For our case, we note that one of the conditions which the <code>mean</code> function should satisfy includes that no runtime array allocation is involved. For the other conditions, let's use the compiler notes emitted by polymorphic-functions to discover what needs to be optimized!</p>
<p>If you are using SBCL (see <code>(cl:lisp-implementation-type)</code>, you might also want to declaim the following to focus on the compiler notes emitted by polymorphic-functions alone.</p>
<pre><code class="language-lisp">(declaim (sb-ext:muffle-conditions sb-ext:compiler-note))
;; You can revert it with
;; (declaim (sb-ext:unmuffle-conditions sb-ext:compiler-note))
</code></pre>
<p>Now, compiling the previous <code>nu:mean</code> polymorph with <code>(optimize speed)</code> emits some notes:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (declare (optimize speed))
  (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
         (number-of-elements
           (etypecase axes
             (null (array-total-size array-like))
             (integer (nu:shape array-like axes))
             (list (loop :for d :in (narray-dimensions array-like)
                         :for i :from 0
                         :with number-of-elements := 1
                         :if (member i axes)
                           :do (setf number-of-elements (* number-of-elements d))
                         :finally (return number-of-elements))))))
    (declare (type real number-of-elements))
    (nu:divide sum number-of-elements :out out)))
</code></pre>
<p>These notes mainly concern <code>nu:sum</code> and <code>nu:divide</code> and are about the type of <code>out</code> being not known. If you are using SLIME (or ALIVE?) you should see the <code>(nu:sum array-like :out out :axes axes :keep-dims keep-dims)</code> and <code>(nu:divide sum number-of-elements :out out)</code> forms being underlined to indicate where the notes are being emitted from.</p>
<p>What do we know about <code>out</code>? That, if it is supplied and if it has to be supplied, then it must be a <code>nu:array</code>. To keep things simple, we check this using whether or not the value of <code>out</code> is of type <code>null</code>. This naive way makes our function looks like this:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (declare (optimize speed))
  (if (null out)
      (locally (declare (type null out))
        (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
               (number-of-elements
                 (etypecase axes
                   (null (array-total-size array-like))
                   (integer (nu:shape array-like axes))
                   (list (loop :for d :in (narray-dimensions array-like)
                               :for i :from 0
                               :with number-of-elements := 1
                               :if (member i axes)
                                 :do (setf number-of-elements (* number-of-elements d))
                               :finally (return number-of-elements))))))
          (declare (type real number-of-elements))
          (nu:divide sum number-of-elements :out out)))
      (locally (declare (type nu:array out))
        (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
               (number-of-elements
                 (etypecase axes
                   (null (array-total-size array-like))
                   (integer (nu:shape array-like axes))
                   (list (loop :for d :in (narray-dimensions array-like)
                               :for i :from 0
                               :with number-of-elements := 1
                               :if (member i axes)
                                 :do (setf number-of-elements (* number-of-elements d))
                               :finally (return number-of-elements))))))
          (declare (type real number-of-elements))
          (nu:divide sum number-of-elements :out out)))))
</code></pre>
<p>And compiling this gets us quite a few notes. Let's focus on one of them:</p>
<pre><code>; (Compiler) Macro of
;    #&lt;POLYMORPHIC-FUNCTIONS:POLYMORPHIC-FUNCTION TWO-ARG-FN/NON-COMPARISON (13)&gt;
; is unable to optimize
;   (TWO-ARG-FN/NON-COMPARISON 'NU:DIVIDE X Y :BROADCAST BROADCAST)
; in
;   (LAMBDA (X Y &amp;KEY (BROADCAST NU:*BROADCAST-AUTOMATICALLY*) (OUT NIL) &amp;AUX)
;     (DECLARE (TYPE NULL OUT)
;              (TYPE T BROADCAST)
;              (TYPE REAL Y)
;              (TYPE T X)
;              (IGNORABLE))
;     (DECLARE (IGNORABLE OUT))
;     (BLOCK NU:DIVIDE
;       (LOCALLY
;         (TWO-ARG-FN/NON-COMPARISON 'NU:DIVIDE X Y :BROADCAST BROADCAST))))
; generated from
;   (NU:DIVIDE SUM NUMBER-OF-ELEMENTS :OUT OUT)
; because:
;
;   Type of
;     X
;   could not be determined
;   Type of
;     BROADCAST
;   could not be determined
</code></pre>
<p>From this, we can tell that <code>x</code> corresponds to <code>sum</code> and that nowhere have we told about the type of <code>sum</code>. In fact, the type of <code>sum</code>: it could be a <code>real</code> or it could be a <code>nu:array</code>. And in the case it is of type <code>nu:array</code>, we must necessarily broadcast. Thus, we have the following new definition:</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (declare (optimize speed))
  (if (null out)
      (locally (declare (type null out))
        (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
               (number-of-elements
                 (etypecase axes
                   (null (array-total-size array-like))
                   (integer (nu:shape array-like axes))
                   (list (loop :for d :in (narray-dimensions array-like)
                               :for i :from 0
                               :with number-of-elements := 1
                               :if (member i axes)
                                 :do (setf number-of-elements (* number-of-elements d))
                               :finally (return number-of-elements))))))
          (declare (type real number-of-elements))
          (if (realp sum)
              (locally (declare (type real sum))
                (nu:divide sum number-of-elements))
              (locally (declare (type nu:array sum))
                (nu:divide sum number-of-elements :out out :broadcast t)))))
      (locally (declare (type nu:array out))
        (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
               (number-of-elements
                 (etypecase axes
                   (null (array-total-size array-like))
                   (integer (nu:shape array-like axes))
                   (list (loop :for d :in (narray-dimensions array-like)
                               :for i :from 0
                               :with number-of-elements := 1
                               :if (member i axes)
                                 :do (setf number-of-elements (* number-of-elements d))
                               :finally (return number-of-elements))))))
          (declare (type real number-of-elements))
          (if (realp sum)
              (locally (declare (type real sum))
                (nu:divide sum number-of-elements))
              (locally (declare (type nu:array sum))
                (nu:divide sum number-of-elements :out out :broadcast t)))))))
</code></pre>
<p>Compiling this gets us some other notes now:</p>
<pre><code>; While compiling
;     (TWO-ARG-FN/NON-COMPARISON 'NU:DIVIDE X Y :BROADCAST BROADCAST)
; in
;   (LAMBDA (X Y &amp;KEY (BROADCAST NU:*BROADCAST-AUTOMATICALLY*) (OUT NIL) &amp;AUX)
;     (DECLARE (TYPE NULL OUT)
;              (TYPE (EQL T) BROADCAST)
;              (TYPE REAL Y)
;              (TYPE ARRAY X)
;              (IGNORABLE))
;     (DECLARE (IGNORABLE OUT))
;     (BLOCK NU:DIVIDE
;       (LOCALLY
;         (TWO-ARG-FN/NON-COMPARISON 'NU:DIVIDE X Y :BROADCAST BROADCAST))))
; generated from
;   (NU:DIVIDE SUM NUMBER-OF-ELEMENTS :OUT OUT :BROADCAST T)
;   Following notes were encountered:
;
;     No applicable POLYMORPH discovered for polymorphic-function
;       TWO-ARG-FN/NON-COMPARISON
;     and ARGS:
;
;       ('NU:DIVIDE X Y :BROADCAST BROADCAST)
;
;     derived to be of TYPES:
;
;       ((EQL NU:DIVIDE) ARRAY REAL (EQL :BROADCAST) (EQL T))
;
;     Available Effective-Type-Lists include:
;
;       (SYMBOL NUMBER NUMBER &amp;KEY (:BROADCAST T) (:OUT NULL))
;       (SYMBOL LIST LIST &amp;KEY (:BROADCAST (OR NULL T)) (:OUT ARRAY))
;       (SYMBOL NUMBER LIST &amp;KEY (:BROADCAST (OR NULL T)) (:OUT ARRAY))
;       (SYMBOL LIST NUMBER &amp;KEY (:BROADCAST (OR NULL T)) (:OUT ARRAY))
;       (SYMBOL LIST LIST &amp;KEY (:BROADCAST (OR NULL T)) (:OUT NULL))
;       (SYMBOL NUMBER LIST &amp;KEY (:BROADCAST (OR NULL T)) (:OUT NULL))
;       (SYMBOL LIST NUMBER &amp;KEY (:BROADCAST (OR NULL T)) (:OUT NULL))
;       (SYMBOL (SIMPLE-ARRAY &lt;TYPE&gt;) (SIMPLE-ARRAY &lt;TYPE&gt;) &amp;KEY
;        (:BROADCAST (OR NULL NULL)) (:OUT (SIMPLE-ARRAY &lt;TYPE&gt;)))
;       (SYMBOL (SIMPLE-ARRAY &lt;TYPE&gt;) (SIMPLE-ARRAY &lt;TYPE&gt;) &amp;KEY
;        (:BROADCAST (OR NULL NULL)) (:OUT NULL))
;       (SYMBOL (ARRAY &lt;TYPE&gt;) (ARRAY &lt;TYPE&gt;) &amp;KEY (:BROADCAST (OR NULL T))
;        (:OUT (ARRAY &lt;TYPE&gt;)))
;       (SYMBOL (ARRAY &lt;TYPE&gt;) (ARRAY &lt;TYPE&gt;) &amp;KEY (:BROADCAST (OR NULL T))
;        (:OUT NULL))
;       (SYMBOL (ARRAY &lt;TYPE&gt;) NUMBER &amp;KEY (:BROADCAST (OR NULL (NOT NULL)))
;        (:OUT (OR NULL (ARRAY &lt;TYPE&gt;))))
;       (SYMBOL NUMBER (ARRAY &lt;TYPE&gt;) &amp;KEY (:BROADCAST (OR NULL (NOT NULL)))
;        (:OUT (OR NULL (ARRAY &lt;TYPE&gt;))))
</code></pre>
<p>No applicable polymorph for <code>divide</code>? How come? Certainly there exists a polymorph for <code>divide</code> that can take in a <code>nu:array</code> and a <code>real</code> as input, right? Careful observation tells us that even though such a polymorph exists (see the last two type lists), such a polymorph also has constraints on the type of <code>out</code>. In particular, the element-type of <code>out</code> must match the element type of <code>x</code> or <code>y</code>, or in our case, the <code>sum</code>. In fact, the element-type of <code>sum</code> if it happens to be an <code>nu:array</code> is also determined by the element-type of the input <code>array-like</code>.</p>
<ol>
<li><strong>divide:</strong> We know that the second argument to <code>divide</code> will always be a <code>real</code>, and as such broadcasting cannot be avoided. However, <code>divide</code> accepts an <code>out</code> argument, and we would like to avoid runtime allocation of <code>out</code>. But, while supplying <code>out</code> we would want to check if or not <code>sum</code> is a real, because if <code>sum</code> is a real, then both <code>sum</code> and <code>number-of-elements</code> are real, and then we do not need to supply <code>out</code>. The following is our modified function then. Let's try to compile with <code>(optimize speed)</code> to see what notes are emitted. </li>
</ol>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
         (number-of-elements
           (etypecase axes
             (null (array-total-size array-like))
             (integer (nu:shape array-like axes))
             (list (loop :for d :in (narray-dimensions array-like)
                         :for i :from 0
                         :with number-of-elements := 1
                         :if (member i axes)
                           :do (setf number-of-elements (* number-of-elements d))
                         :finally (return number-of-elements))))))
    (declare (type real number-of-elements))
    (if (realp sum)
        (locally (declare (type real sum))
          (nu:divide sum number-of-elements))
        (locally (declare (type nu:array sum))
          (nu:divide sum number-of-elements :out out :broadcast t)))))
</code></pre>
<pre><code class="language-lisp">(defun mean-caller (x)
  (declare (optimize speed))
  (nu:mean x))
</code></pre>
<p>The crucial note this emits is:</p>
<pre><code>    Type of
      X
    could not be determined
</code></pre>
<p>So, we specify the type of <code>x</code>:</p>
<pre><code>(defun mean-caller (x)
  (declare (optimize speed)
           (type (simple-array single-float) x))
  (nu:mean x))
</code></pre>
<p>This gets us more information.</p>
<pre><code class="language-lisp">(defpolymorph nu:mean ((array-like nu:array) &amp;key out axes keep-dims) t
  (let* ((sum (nu:sum array-like :out out :axes axes :keep-dims keep-dims))
         (number-of-elements
           (etypecase axes
             (null (array-total-size array-like))
             (integer (nu:shape array-like axes))
             (list (loop :for d :in (narray-dimensions array-like)
                         :for i :from 0
                         :with number-of-elements := 1
                         :if (member i axes)
                           :do (setf number-of-elements (* number-of-elements d))
                         :finally (return number-of-elements))))))
    (declare (type real number-of-elements))
    (nu:divide sum number-of-elements :out out)))
</code></pre>
<h3 id="interfacing-with-magicl">Interfacing with magicl</h3>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script>var base_url = '.';</script>
    <script src="js/theme_extra.js" defer></script>
    <script src="js/theme.js" defer></script>
      <script src="search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>

<!--
MkDocs version : 1.4.2
Build Date UTC : 2023-06-17 07:40:45.128727+00:00
-->
